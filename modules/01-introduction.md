# Введение

## Начинаем программировать

### Сравнение логической переменной с TRUE

Специально вынес повыше, чтобы все знали: так делать **ни в коем случае** нельзя. То есть, оно, конечно, будет работать, но именно такой код выделяет тех, кто думает, от тех, кто *просто пишет*.

#### Как делать не надо

``` javascript
if (typeof(a) === "boolean") {
  if (a === true) {
     return "Нет, ну правда же, правда?";
  }
}
```

#### Как будет короче и понятней

``` javascript
if (typeof(a) === "boolean") {
  if (a) {
     return "Правда, только правда и ничего, кроме правды";
  }
}
```

### Несогласованность условий

Занудное название, но ошибка довольно серьёзная. А именно – если `if`-ы расположены
таким образом и условия в них сделаны так, что некоторые проверки никогда не будут
выполнены, значит что-то в коде откровенно не так.

Например, в задании написано:

> Если `a` – массив, сделайте то-то, а если массивы `a` и `b`, сделайте другое.

#### Неправильный подход

``` javascript
if (Array.isArray(a)) {
  return "Ух ты, целый массив!";
}

if (Array.isArray(a) && Array.isArray(b)) {
  return "Ух ты, целых два массива!";
}
```

И, вроде бы, условия правильные, но, если выполняется первое условие, то выполнение до второго просто никогда не дойдёт.

#### Правильный подход

``` javascript
if (Array.isArray(a)) {
  if (Array.isArray(b)) {
    return "Ух ты, целых два массива!";
  }

  return "Ух ты, целый массив!";
}
```

### ELSE после IF внутри которого сделан RETURN

Ошибка несерьёзная, но делает код менее читаемым. Поэтому, скорее всего, я придерусь.

#### Как, по-моему, некрасиво

``` javascript
if (typeof(a) === "number") {
  return "Передано число, да!";
} else if (typeof(a) === "string") {
  // ...
}
```

#### Как предлагаю я

``` javascript
if (typeof(a) === "number") {
  return "Глянь-ка, ты передал число!";
}

if (typeof(a) === "string") {
  // ...
}
```

#### Почему

Если первое условие `typeof(a) === "number"` выполнилось, выполнение не пойдёт дальше закрывающей скобки `if`. Соответственно, `else` в данном случае избыточно.

### Небрежность

В постановке не сказано явно (во всяком случае, до сих пор), что если a и b - массивы, то они имеют одинаковую длину. Если есть возможность, в подобных случаях нужно:

1. Выяснить, действительно ли это будет именно так
2. Если выяснить не получается или некогда, сделать так, чтобы в худшем случае ничего не упало.

#### Если мы ничего не подозреваем

``` javascript
for(var i = 0; i < a.length; i++) {
  sum += a[i] * b[i];
}
```

Когда интерпретатор попросит несуществующий элемент массива, он получит `undefined`. Потом он попытается умножить его на число, и тут ему станет плохо. Не надо обижать интерпретатор.

#### Постоянная бдительность

``` javascript
var minLength = Math.min(a.length, b.length);
for(var i = 0; i < minLength; i++) {
  sum += a[i] * b[i];
}
```

Очень может быть, что предосторожность в данном случае – излишняя, но привычка-то хорошая, верно?

### Объявление переменной в цикле

Само по себе объявление переменной внутри `for` ничего страшного не сделает.
Ведь на самом деле переменная всё-равно объявляется на всю функцию и будет видна
в пределах функции, но кое-что может пойти не так, пусть даже и не в этот раз.

#### Что может пойти не так?

``` javascript
if (Array.isArray(b)) {
   for(var i = 0; i < b.length; i++) { ... }
} else {
   for(var i = 0; i < a.length; i++) { ... }
}
```

Интерпретатор ничего не скажет. Он спокойно объявит переменную один раз и никто ничего не заметит. А вот у тебя появится неприятная привычка не следить за объявленными переменными. И когда в следующий раз ты объявишь переменную с одинаковым именем два раза, `eslint` возьмёт да и не пропустит твой пулл-реквест.

#### Что же теперь делать?

Выносим переменную в верхнюю часть функции и убираем `var` из цикла. Всё.

``` javascript
var i;
// ...
if (Array.isArray(b)) {
   for(i = 0; i < b.length; i++) { ... }
} else {
   for(i = 0; i < a.length; i++) { ... }
}
```

### Излишнее обращение к свойству/функции

Старайтесь, по возможности, ограничить количество обращений к свойству объекта или к функции, в случаях, когда есть основания считать, что результат всегда будет одинаковым.

#### Так хуже

``` javascript
for(var i = 0; i < a.length; i++) {
  sum += a[i];
}
```

#### Так лучше

``` javascript
var arrayLength = a.length;
for(var i = 0; i < arrayLength; i++) {
  sum += a[i];
}
```

#### Так совсем хорошо

но этот материал изучается чуть позже :)

``` javascript
var sum = a.inject(function(sum, value) { return sum + value; }, 0);
```

### Страшный секрет

На самом деле, в рамках этого задания нет необходимости выяснять, является ли параметр массивом. Как так? А вот так: после того как мы выяснили, что первый параметр – не логическое значение и не число, для `a` и `b` остаётся только два варианта: массив или `undefined`. Для того, чтобы это проверить достаточно после предыдущих проверок сделать:

``` javascript
if(a) {
   if(b) {
     return "a и b - массивы!";
   }
   return "a - массив!";
}
```

Используя этот нехитрый лайфхак можно немного сэкономить на поисках способа определения, является ли параметр массивом.

P.S. Я об этом узнал у преподавателя после того, как придумал свой способ и обнаружил несколько стандартных :)