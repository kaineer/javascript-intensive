# Введение

## Начинаем программировать

### Сравнение логической переменной с TRUE

Специально вынес повыше, чтобы все знали: так делать **ни в коем случае** нельзя. То есть, оно, конечно, будет работать, но именно такой код выделяет тех, кто думает, от тех, кто *просто пишет*.

#### Как делать не надо

```.javascript
if (typeof(a) === "boolean") {
  if (a === true) {
     return "Нет, ну правда же, правда?";
  }
}
```

#### Как будет короче и понятней

```.javascript
if (typeof(a) === "boolean") {
  if (a) {
     return "Правда, только правда и ничего, кроме правды";
  }
}
```

### Несогласованность условий

Занудное название, но ошибка довольно серьёзная. А именно – если `if`-ы расположены
таким образом и условия в них сделаны так, что некоторые проверки никогда не будут
выполнены, значит что-то в коде откровенно не так.

Например, в условии написано:

> Если `a` – массив, сделайте то-то, а если массивы `a` и `b`, сделайте другое.

#### Неправильный подход

```.javascript
if (Array.isArray(a)) {
  return "Ух ты, целый массив!";
}

if (Array.isArray(a) && Array.isArray(b)) {
  return "Ух ты, целых два массива!";
}
```

И, вроде бы, условия правильные, но, если выполняется первое условие, то выполнение до второго просто никогда не дойдёт.

#### Правильный подход

```.javascript
if (Array.isArray(a)) {
  if (Array.isArray(b)) {
    return "Ух ты, целых два массива!";
  }
  
  return "Ух ты, целый массив!";
}
```

### ELSE после IF внутри которого сделан RETURN

Ошибка несерьёзная, но делает код менее читаемым. Поэтому, скорее всего, я придерусь.

#### Как, по-моему, некрасиво

```.javascript
if (typeof(a) === "number") {
  return "Передано число, да!";
} else if (typeof(a) === "string") {
  // ...
}
```

#### Как предлагаю я

```.javascript
if (typeof(a) === "number") {
  return "Глянь-ка, ты передал число!";
}

if (typeof(a) === "string") {
  // ...
}
```

#### Почему

Если первое условие `typeof(a) === "number"` выполнилось, выполнение не пойдёт дальше закрывающей скобки `if`. Соответственно, `else` в данном случае избыточно.

### Небрежность

В постановке не сказано явно (во всяком случае, до сих пор), что если a и b - массивы, то они имеют одинаковую длину. Если есть возможность, в подобных случаях нужно:

1. Выяснить, действительно ли это будет именно так
2. Если выяснить не получается или некогда, сделать так, чтобы в худшем случае ничего не упало.

#### Если мы ничего не подозреваем

```.javascript
for(var i = 0; i < a.length; i++) {
  sum += a[i] * b[i];
}
```

Когда интерпретатор попросит несуществующий элемент массива, он получит `undefined`. Потом он попытается умножить его на число, и тут ему станет плохо. Не надо обижать интерпретатор.

#### Постоянная бдительность

```.javascript
var minLength = Math.min(a.length, b.length);
for(var i = 0; i < minLength; i++) {
  sum += a[i] * b[i];
}
```

Очень может быть, что предосторожность в данном случае – излишняя, но привычка-то хорошая, верно?

### Объявление переменной в цикле

Само по себе объявление переменной внутри `for` ничего страшного не сделает.
Ведь на самом деле переменная всё-равно объявляется на всю функцию и будет видна 
в пределах функции, но кое-что может пойти не так, пусть даже и не в этот раз.

#### Что может пойти не так?

```.javascript
if (Array.isArray(b)) {
   for(var i = 0; i < b.length; i++) { ... }
} else {
   for(var i = 0; i < a.length; i++) { ... }
}
```

Интерпретатор ничего не скажет. Он спокойно объявит переменную один раз и никто ничего не заметит. А вот у тебя появится неприятная привычка не следить за объявленными переменными. И когда в следующий раз ты объявишь переменную с одинаковым именем два раза, `eslint` возьмёт да и не пропустит твой пулл-реквест.

#### Что же теперь делать?

Выносим переменную в верхнюю часть функции и убираем var из цикла. Всё.

```.javascript
var i;
// ...
if (Array.isArray(b)) {
   for(i = 0; i < b.length; i++) { ... }
} else {
   for(i = 0; i < a.length; i++) { ... }
}
```
